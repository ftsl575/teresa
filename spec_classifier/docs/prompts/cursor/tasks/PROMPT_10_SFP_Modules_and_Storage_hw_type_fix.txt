PROMPT 10 — Post‑P9 hotfix: SFP Modules (Multi) DAC cables + FRONT/REAR STORAGE hw_type

ROLE
You are Cursor acting inside repo. Implement the minimal, deterministic fix. NO GUESSES. YAML-only if possible. If acceptance fails, stop and report exact failing case (file, row, OptionID, expected vs actual).

CONTEXT (from latest full dl1–dl6 run artifacts)
1) dl3: unknown_count = 1 caused by an item in module_name "SFP Modules (Multi)" with option_name containing a Twinax/DAC direct attach cable. It fell through entity rules and became UNKNOWN.
2) dl4: hw_type_null_count = 2 caused by module_name "FRONT STORAGE" and "REAR STORAGE" rows being HW but hw_type stayed null:
   - OptionID GBEZWO8 | FRONT STORAGE | "Chassis with up to 24x2.5\" Drives" | expected hw_type=chassis
   - OptionID GOXF0L2 | REAR STORAGE  | "No Rear Storage"                     | expected hw_type=chassis (state ABSENT stays as-is)

TARGET BEHAVIOR (explicit)
A) Any DAC/Twinax/SFP direct-attach cable rows under module_name "SFP Modules (Multi)" must be:
   - entity_type = HW
   - hw_type = cable
   - device_type = sfp_cable
B) FRONT STORAGE / REAR STORAGE rows must be:
   - entity_type = HW (unchanged)
   - hw_type = chassis
   - state behavior unchanged (e.g., "No Rear Storage" stays ABSENT)

PATCH SCOPE (explicit; keep minimal)
Touch ONLY:
1) spec_classifier\rules\dell_rules.yaml

Do NOT touch:
- golden/ (no golden updates in this prompt)
- any Python
- tests (unless absolutely required to prevent regressions; prefer YAML-only)

TASKS

Step 1 — Fix entity_type for "SFP Modules (Multi)" so it no longer becomes UNKNOWN
In dell_rules.yaml, in the HW entity routing rules (hw_rules / the block that assigns entity_type=HW based on module_name),
add a NEW module_name match that covers this module:

- field: module_name
- pattern: '(?i)\bSFP\s+Modules?\b'
- entity_type: HW
- rule_id: HW-010-SFP-MODULES-MULTI

Place it near other HW module_name routing rules (same block), without reordering unrelated rule blocks.

Step 2 — Ensure hw_type=cable for those SFP Modules (Multi) DAC rows
In dell_rules.yaml, in hw_type_rules.rules (Layer 3 regex rules),
add a NEW rule (before any broad/late catch-alls) that sets hw_type=cable when module_name indicates SFP Modules:

- field: module_name
- pattern: '(?i)\bSFP\s+Modules?\b'
- hw_type: cable

This should not affect optics/transceiver handling in other modules; it only targets SFP Modules module_name.

Step 3 — Ensure device_type=sfp_cable for DAC/Twinax direct attach cable option names
In dell_rules.yaml, in device_type_rules.rules,
ensure there is a rule that matches DAC/Twinax/Direct Attach cable option_name and sets device_type=sfp_cable, and that it applies when entity_type is HW.

If an existing rule already sets device_type=sfp_cable but is tied to a removed logistic rule_id, do NOT reintroduce logistic routing.
Instead, add a NEW explicit rule:

- field: option_name
- pattern: '(?i)\b(sfp|sfp\+|sfp28|twinax|dac|direct\s+attach)\b.*\b(cable|twinax)\b'
- device_type: sfp_cable
- rule_id: DEC-010-SFP-DAC-CABLE

Place it with other cable/network device_type rules; do not reorder unrelated blocks.

Step 4 — Fix dl4 FRONT STORAGE / REAR STORAGE hw_type nulls
In dell_rules.yaml, in hw_type_rules.rules (Layer 3 regex rules),
add a NEW rule that sets hw_type=chassis when module_name indicates FRONT STORAGE or REAR STORAGE:

- field: module_name
- pattern: '(?i)\b(FRONT\s+STORAGE|REAR\s+STORAGE)\b'
- hw_type: chassis

Place it in a sensible position among other chassis/backplane/storage related rules, without reordering unrelated blocks.

ACCEPTANCE (must be met)
1) Full dl1–dl6 run summary invariants:
   - dl3 unknown_count becomes 0 (was 1)
   - dl4 hw_type_null_count becomes 0 (was 2)
   - dl6 remains: unknown_count = 0, hw_type_null_count = 0

2) Exact spot-checks (must match):
   - dl3: OptionID GU0B9PV (the Twinax Direct Attach Cable row in SFP Modules (Multi)):
       entity_type=HW, state=PRESENT, hw_type=cable, device_type=sfp_cable
   - dl4: OptionID GBEZWO8:
       entity_type=HW, state=PRESENT, hw_type=chassis
   - dl4: OptionID GOXF0L2:
       entity_type=HW, state=ABSENT, hw_type=chassis

3) No new UNKNOWN rows introduced in any dataset.

COMMANDS (PowerShell; run from spec_classifier folder; full paths)
```powershell
Set-Location -Path "C:\Users\G\Desktop\TERESA\spec_classifier"

# Clean prior runs
Remove-Item -Recurse -Force "C:\Users\G\Desktop\TERESA\spec_classifier\output\run_*" -ErrorAction SilentlyContinue

# Run dl1–dl6
foreach ($n in 1..6) {
    python "C:\Users\G\Desktop\TERESA\spec_classifier\main.py" `
        --input "C:\Users\G\Desktop\TERESA\spec_classifier\test_data\dl$n.xlsx" `
        --output-dir "C:\Users\G\Desktop\TERESA\spec_classifier\output"
}

# Print last 6 run summaries (must show dl3 unknown_count=0 and dl4 hw_type_null_count=0)
python -c "
import json, glob, os
runs = sorted(glob.glob(r'C:\\Users\\G\\Desktop\\TERESA\\spec_classifier\\output\\run_*\\run_summary.json'))
assert len(runs) >= 6, f'Expected >=6 runs, found {len(runs)}'
print('--- RUN SUMMARY CHECK ---')
for path in runs[-6:]:
    with open(path, encoding='utf-8') as f: s = json.load(f)
    print(os.path.basename(os.path.dirname(path)))
    print('  hw_type_null_count:', s.get('hw_type_null_count'))
    print('  unknown_count     :', s.get('unknown_count'))
"

# Spot-check OptionIDs in annotated outputs (scan all run folders)
python -c "
import openpyxl, glob, os
targets = {
  'GU0B9PV': ('HW','PRESENT','cable','sfp_cable'),
  'GBEZWO8': ('HW','PRESENT','chassis',None),
  'GOXF0L2': ('HW','ABSENT','chassis',None),
}
files = sorted(glob.glob(r'C:\\Users\\G\\Desktop\\TERESA\\spec_classifier\\output\\run_*\\*_annotated.xlsx'))
assert files, 'No annotated xlsx files found under output/run_*'
found = {k:0 for k in targets}
for fp in files:
    wb = openpyxl.load_workbook(fp)
    ws = wb.active
    h = [c.value for c in ws[1]]
    idx = {name:i for i,name in enumerate(h)}
    for row in ws.iter_rows(min_row=2):
        oid = row[idx['option_id']].value
        if oid in targets:
            got = (
              row[idx['entity_type']].value,
              row[idx['state']].value,
              row[idx['hw_type']].value,
              row[idx['device_type']].value if 'device_type' in idx else None
            )
            exp = targets[oid]
            if got != exp:
                raise SystemExit(f'FAIL {os.path.basename(fp)} {oid}: got {got} expected {exp}')
            found[oid] += 1
print('PASS spot-checks; occurrences:', found)
"
```

DELIVERABLE
- A single commit / PR that changes ONLY spec_classifier\rules\dell_rules.yaml
- Report the exact diff summary (git diff --stat) and paste the updated run summary check output (6 runs).
